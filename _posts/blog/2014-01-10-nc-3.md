---
layout: post
title: Twemproxy(Nutcracker)源码分析--proxy conn与client conn的生成与处理
category: blog
---

proxy 相对于client端其实是服务器端， 首先要建立proxy的socket

简单介绍下unix 服务器端socket 建立的步骤
1.创建一个socket
socket = socket(PF_INET, SOCK_STREAM, 0)

2.给socket绑定一个地址
bind(sock, &addr, sizeof(addr))

3.监听准备接入请求
listen(sock, queue_size)

4.设置socket为非阻塞模式
fcntl(sockfd, F_SETFL, O_NONBLOCK);

5.实际等待接收请求
accept(p->sd, NULL, NULL);

unix 网络编程的相关资料有更具体的介绍

下面我们来看nc 中proxy socket的建立
在nc_proxy.c 的proxy_listen 函数实现了上面的步骤

	static rstatus_t proxy_listen(struct context *ctx, struct conn *p)
    {
	    rstatus_t status;
	    struct server_pool *pool = p->owner;
	
	    ASSERT(p->proxy);
	
	    p->sd = socket(p->family, SOCK_STREAM, 0);
	    if (p->sd < 0) {
	        log_error("socket failed: %s", strerror(errno));
	        return NC_ERROR;
	    }
	
	    status = proxy_reuse(p);
	    if (status < 0) {
	        log_error("reuse of addr '%.*s' for listening on p %d failed: %s",
	                  pool->addrstr.len, pool->addrstr.data, p->sd,
	                  strerror(errno));
	        return NC_ERROR;
	    }
	
	    status = bind(p->sd, p->addr, p->addrlen);
	    if (status < 0) {
	        log_error("bind on p %d to addr '%.*s' failed: %s", p->sd,
	                  pool->addrstr.len, pool->addrstr.data, strerror(errno));
	        return NC_ERROR;
	    }
	
	    status = listen(p->sd, pool->backlog);
	    if (status < 0) {
	        log_error("listen on p %d on addr '%.*s' failed: %s", p->sd,
	                  pool->addrstr.len, pool->addrstr.data, strerror(errno));
	        return NC_ERROR;
	    }
	
	    status = nc_set_nonblocking(p->sd);
	    if (status < 0) {
	        log_error("set nonblock on p %d on addr '%.*s' failed: %s", p->sd,
	                  pool->addrstr.len, pool->addrstr.data, strerror(errno));
	        return NC_ERROR;
	    }
    }
    
中间多了一步 设置端口重用。

	status = proxy_reuse(p);
服务程序停止后想立即重启，而新套接字依旧使用同一端口，这一设置非常有用


执行完proxy_listen后proxy 已经开始准备好接受客户端的请求了


接收client请求并生成client conn
